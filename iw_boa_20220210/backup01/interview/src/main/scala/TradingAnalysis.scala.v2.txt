import scala.io.Source
import scala.util.Try

object TradingAnalysis extends App {
  implicit def str2BigDecimal(in: String): Option[BigDecimal] = Try(BigDecimal(in)).toOption

  implicit def str2BigInt(in: String): Option[BigInt] = Try(BigInt(in)).toOption

  //  direcorty => List[File] => List[list[Trading]] => List[Trading]
  //  List[File]

  val marketFile = "C:\\tmp\\test_data\\my_marks.txt"
  val bufferedSourceMarket = Source.fromFile(marketFile)
  val markerLines = bufferedSourceMarket.getLines()
  val tickerPriceList = markerLines.map {
    line => {
      val cols = line.split(" ").map(_.trim)
      tickerPrice(cols(0), cols(1))
    }
  }.toList
  println(s"All tickers:")
  tickerPriceList.foreach(t => println(t))
  bufferedSourceMarket.close()

  val tradingFile1 = "C:\\tmp\\test_data\\my_xaa"
  val bufferedSourceTrading1 = Source.fromFile(tradingFile1)
  val trading1Lines = bufferedSourceTrading1.getLines()
  val tradeList = trading1Lines.map {
    line =>
      val cols = line.split("\t").map(_.trim)
      trading(cols(0), cols(1), cols(2), cols(3), cols(4), cols(5))
  }.toList

  val riskResultList = tradeList.groupBy(_.ticker).map {
    case (ticker, tradingList) =>
      val risk = tradingList.flatMap { rec =>
        val inOut = if (rec.action.toLowerCase() == "buy") 1 else -1
        rec.numShares.flatMap(shares => rec.tradePrice.map(price => inOut * price * BigDecimal(shares))).toList
      }.sum
      (ticker, risk)
  }.toList
  val top20RiskList = riskResultList.sortBy(_._2).take(20)
  println(s"Top 20 risks")
  top20RiskList.map(t => println(t))

  /*
  //works but not sorted by top20RiskList
  val top20RiskValue = tickerPriceList.flatMap{ case t => top20RiskList.toMap.get(t.ticker).map(ticker => (t.ticker, t
    .curPrice))}
   */
  val top20RiskValue = top20RiskList.flatMap { case (symbol, risk) => tickerPriceList.zipWithIndex.map { case (v, i)
  => (v.ticker, v.curPrice)
  }.toMap.get(symbol).map(tp =>
    (symbol, tp.get))
  }

  println(s"Top 20 risks with current market value")
  top20RiskValue.map(t => println(t))


  val partyResultList = tradeList.groupBy(_.party).map {
    case (symbol, tradingList) =>
      val risk = tradingList.flatMap { rec =>
        rec.numShares.flatMap(shares => rec.tradePrice.map(price => price * BigDecimal(shares))).toList
      }.sum
      (symbol, risk)
  }.toList
  val top20PartyList = partyResultList.sortBy(_._2).take(20)
  println(s"Top 20 parties")
  top20PartyList.map(t => println(t))

  bufferedSourceTrading1.close()
}
